
Stack-Based Arithmetic and Logic Unit (8-bit)
=============================================

The stack-based ALU is a more powerfull form of an Arithmetic and Logic Unit (ALU) that can also be used as a register or an instruction sequencer.

For more detailed explanation of how and why, google "evaluating a postfix expression using a stack".

Inputs and Outputs
===================

Ribbon Inputs:
	data-in low bits
	data-in high bits
	operation
	clock (edge triggered, if not connected, uses the game clock)

Ribbon Ouputs:
	data-out low bits
	data-out high bits
	status flags

Operations Summary
===================

Operations are split into 4 categories: 
	00 - data
	01 - special
	10 - arithmetic
	11 - bitwise logic
Each category has 4 operations.

The only operations that read from data-in are:
	0010 - push
	0011 - replace
	0110 - queue (put on top of stack)

The rest get their inputs from popping the stack.

The bottom of the stack is always available on data out. (Except for the standby instruction?  I haven't decided.)

Arithmetic and bitwise logic operations are performebed by the following sequence:
1. pop number for right-hand side of operation
2. pop number for left-hand side of operation
3. perform operation
4. push result of operation (also sent to data out)
Note:
	Multiply and divide push TWO values onto the stack.
	Only the last value pushed onto the stack is sent to data out.
	To get the other value, pop the stack.
5. set status flags


There are four status flags, all available on the status flags output ribbon:
	0001 - zero
	0010 - sign (1 if negative, 0 if positive)
	0100 - carry / borrow / overflow
	1000 - stack fault

The stack can only hold up to 256 values.  (I had to set a limit, and that seemed reasonable.)
Pushing the stack when its full or poping it when it's empty will set the stack fault flag. (And the push or pop will fail.)


Operation List (OpCodes)
===================
00 - data
	0000 - no operation (standby)
	0001 - pop (discard)
	0010 - push value
	0011 - replace value (equivalent to a 0001 - pop followed by 0010 - push value)
01 - special
	0100 - pop and shift (sign determines direction)
	0101 - increment
	0110 - queue (put on top of stack instead of bottom)
	0111 - push 0
10 - arithmetic
	1000 - pop and add
	1001 - pop and subtract
	1010 - pop and multiply (pushes high bits on stack first, then low bits)
	1011 - pop and divide/mod (pushes result on stack first, then remainder (modulus))
11 - bitwise logic
	1100 - pop and or
	1101 - pop and and
	1110 - pop and xor
	1111 - pop and xnor
	
	
Other Operations
===================
How to do other operations with multiple steps:
	to negate (take additive inverse): push 0, push value, subtract
	to not (bitwise inverse): push 0, xnor.
	to push a 1: push 0, increment
