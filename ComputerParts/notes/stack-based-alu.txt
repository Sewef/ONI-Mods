
Stack-Based Arithmetic and Logic Unit (8-bit)
=============================================

The stack-based ALU is a more powerfull form of an Arithmetic and Logic Unit (ALU) that can also be used as a register or an instruction sequencer.

For more detailed explanation of how and why, read up on "Stack Machines".
* https://en.wikipedia.org/wiki/Stack_machine
* https://users.ece.cmu.edu/~koopman/stack_computers/chap6.html

Inputs and Outputs
===================

Ribbon Inputs:
	data-in low bits
	data-in high bits
	operation
	clock (edge triggered, if not connected, uses the game clock)

Ribbon Ouputs:
	data-out low bits
	data-out high bits
	status flags

Operations Summary
===================

Operations are split into 4 categories: 
	00 - data / stack
	01 - special
	10 - arithmetic
	11 - bitwise logic
Each category has 4 operations.

The only operations that read from data-in are:
	0010 - push
	0011 - replace
	0110 - queue (put on top of stack)

The rest get their inputs from popping the stack.

The top of the stack is always available on data out. (Except for the standby instruction?  I haven't decided.)

Arithmetic and bitwise logic operations are performebed by the following sequence:
1. pop number for right-hand side of operation ("top")
2. pop number for left-hand side of operation ("next")
3. perform operation
4. push result of operation (also sent to data out)
Note:
	Multiply and divide push TWO values onto the stack.
	Only the last value pushed onto the stack is sent to data out.
	To get the other value, pop the stack.
5. set status flags

For example, if the stack looks like this:

	top
	next

And the operation is divide, then after the operation, the stack will look like this:

	next % top
	next / top

There are four status flags, all available on the status flags output ribbon:
	0001 - zero
	0010 - sign (1 if negative, 0 if positive)
	0100 - carry / borrow / overflow
	1000 - stack fault

The stack can only hold up to 256 values.  (I had to set a limit, and that seemed reasonable.)
Pushing the stack when its full or poping it when it's empty will set the stack fault flag. (And the push or pop will fail.)


Operation List (OpCodes)
===================
00 - data / stack
	0000 - standy (do nothing)
	0001 - peek (send top of stack to data out)
	0010 - pop (drop) discard top of stack
	0011 - push (push data in to top of stack)
01 - special
	0100 - increment top of stack
	0101 - swap top and next (might change)
	0110 - copy from stack index (if 0, returns the current size of the stack) 
	0111 - undecided (write to stack?)
	swap top and next? ("swap") copy top? (""dup")  read from stack depth (top specifies index, data is copied to top)?  same thing but write next?
10 - arithmetic
	1000 - pop and add
	1001 - pop and subtract
	1010 - pop and multiply (pushes high bits on stack first, then low bits)
	1011 - pop and divide/mod (pushes result on stack first, then remainder (modulus))
11 - bitwise logic
	1100 - pop and or
	1101 - pop and and
	1110 - pop and xor 
	1111 - pop and xnor - spare instruction?

a pop can be don via push 0, and, or
what is a peek 0? - (push 0, peek 0, could be a push) spare isntruction
	
Other Operations
===================
How to do other operations with multiple steps:
	to negate (take additive inverse): push 0, push value, subtract
	to not (bitwise inverse): push 0, xnor.
	to push a 1: push 0, increment
